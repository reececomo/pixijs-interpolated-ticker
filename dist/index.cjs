"use strict";exports.InterpolatedTicker=class InterpolatedTicker{constructor({app:t,updateIntervalMs:e=1e3/60,initialCapacity:i=500}){this.maxUpdatesPerRender=3,this._previousTime=0,this._accumulator=0,this._isRunning=!1,this._speed=1,this._maxRenderFPS=-1,this._maxRenderIntervalMs=-1,this._idxContainersCount=0,this._prevIdxContainersCount=0,this._maxIdx=0,this._releasedIdx=[],this._app=t,this._targetUpdateIntervalMs=e,this._updateIntervalMs=e;const s=i;this._capacity=s,this._idxContainers=new Array(this._capacity);const a=Float32Array.BYTES_PER_ELEMENT*s,r=12*a;this._buffer=new ArrayBuffer(r);let n=0;const allocate=()=>new Float32Array(this._buffer,a*n++,s);this._prevX=allocate(),this._prevY=allocate(),this._prevRotation=allocate(),this._prevScaleX=allocate(),this._prevScaleY=allocate(),this._prevAlpha=allocate(),this._shadowX=allocate(),this._shadowY=allocate(),this._shadowRotation=allocate(),this._shadowScaleX=allocate(),this._shadowScaleY=allocate(),this._shadowAlpha=allocate()}set speed(t){this._speed=t,this._updateIntervalMs=this._targetUpdateIntervalMs/t}get speed(){return this._speed}get updateIntervalMs(){return this._targetUpdateIntervalMs}set updateIntervalMs(t){this._targetUpdateIntervalMs=t,this._updateIntervalMs=t/this._speed}get maxRenderFPS(){return this._maxRenderFPS}set maxRenderFPS(t){this._maxRenderFPS=t<=0?-1:t,this._maxRenderIntervalMs=t<=0?-1:1e3/t}start(){if(this._isRunning)return;const loop=()=>{var t,e;const i=performance.now(),s=i-this._previousTime;if(s<this._maxRenderIntervalMs)this._isRunning&&requestAnimationFrame(loop);else{for(this._previousTime=i,this._accumulator=Math.min(this._accumulator+s,this._updateIntervalMs*this.maxUpdatesPerRender);this._accumulator>=this._updateIntervalMs;)this._captureContainers(),null===(t=this.update)||void 0===t||t.call(this,this._updateIntervalMs),this._accumulator-=this._updateIntervalMs;this._interpolateContainers(this._accumulator),null===(e=this.onRender)||void 0===e||e.call(this,s),this._app.renderer.render(this._app.stage),this._restoreContainers(),this._isRunning&&requestAnimationFrame(loop)}};this._isRunning=!0,this._previousTime=performance.now(),requestAnimationFrame(loop)}stop(){this._isRunning=!1}getDefaultInterpolation(t){return!0}_resizeBuffer(t){const e=Float32Array.BYTES_PER_ELEMENT*t,i=new ArrayBuffer(12*e);let s=0;const allocateAndCopy=a=>{const r=new Float32Array(i,e*s++,t);return r.set(a),r};this._prevX=allocateAndCopy(this._prevX),this._prevY=allocateAndCopy(this._prevY),this._prevRotation=allocateAndCopy(this._prevRotation),this._prevScaleX=allocateAndCopy(this._prevScaleX),this._prevScaleY=allocateAndCopy(this._prevScaleY),this._prevAlpha=allocateAndCopy(this._prevAlpha),this._shadowX=allocateAndCopy(this._shadowX),this._shadowY=allocateAndCopy(this._shadowY),this._shadowRotation=allocateAndCopy(this._shadowRotation),this._shadowScaleX=allocateAndCopy(this._shadowScaleX),this._shadowScaleY=allocateAndCopy(this._shadowScaleY),this._shadowAlpha=allocateAndCopy(this._shadowAlpha),this._buffer=i,this._capacity=t}_captureContainers(){this._idxContainersCount=0,this._captureContainersTraverseSubtree(this._app.stage);for(let t=this._maxIdx;t<this._prevIdxContainersCount;t++)this._markReleased(this._idxContainers[t]),this._idxContainers[t]=void 0;this._prevIdxContainersCount=this._maxIdx}_captureContainersTraverseSubtree(t){var e,i,s;if(t.destroyed)return;if(!1===t.interpolation)return;if(void 0===t.interpolation){if(!this.getDefaultInterpolation(t))return void(t.interpolation=!1);t.interpolation=!0}this._maxIdx+1>=this._capacity&&this._resizeBuffer(2*this._capacity);const a=null!==(i=null!==(e=t._interpIdx)&&void 0!==e?e:this._releasedIdx.pop())&&void 0!==i?i:this._maxIdx++;void 0===t._interpIdx&&(t._interpIdx=a),this._prevX[a]=t.position._x,this._prevY[a]=t.position._y,this._prevScaleX[a]=t.scale._x,this._prevScaleY[a]=t.scale._y,this._prevRotation[a]=t.rotation,this._prevAlpha[a]=t.alpha,this._idxContainers[this._idxContainersCount++]=t;const r=null!==(s=t.interpolatedChildren)&&void 0!==s?s:t.children;for(let t=0;t<r.length;t++)this._captureContainersTraverseSubtree(r[t])}_interpolateContainers(t){const e=t/this._updateIntervalMs,i=e>1?1:e<0?0:e;for(let t=0;t<this._idxContainersCount;t++){if(void 0===this._idxContainers[t])continue;if(this._idxContainers[t].destroyed){this._markReleased(this._idxContainers[t]);continue}const e=this._idxContainers[t],s=e._interpIdx,a=e.interpolationWraparound;let r=(this._shadowX[s]=e.position._x)-this._prevX[s],n=(this._shadowY[s]=e.position._y)-this._prevY[s];if(void 0!==a){const t=a.xRange,e=a.yRange;r=((r+t/2)%t+t)%t-t/2,n=((n+e/2)%e+e)%e-e/2}e.position.set(this._prevX[s]+i*r,this._prevY[s]+i*n),e.scale.set(this._prevScaleX[s]+i*((this._shadowScaleX[s]=e.scale._x)-this._prevScaleX[s]),this._prevScaleY[s]+i*((this._shadowScaleY[s]=e.scale._y)-this._prevScaleY[s]));let h=(this._shadowRotation[s]=e.rotation)-this._prevRotation[s];h>Math.PI?h-=2*Math.PI:h<-Math.PI&&(h+=2*Math.PI),e.rotation=this._prevRotation[s]+i*h,e.alpha=this._prevAlpha[s]+i*((this._shadowAlpha[s]=e.alpha)-this._prevAlpha[s])}}_restoreContainers(){for(let t=0;t<this._idxContainersCount;t++){if(void 0===this._idxContainers[t])continue;if(this._idxContainers[t].destroyed){this._markReleased(this._idxContainers[t]);continue}const e=this._idxContainers[t],i=e._interpIdx;e.position.set(this._shadowX[i],this._shadowY[i]),e.scale.set(this._shadowScaleX[i],this._shadowScaleY[i]),e.rotation=this._shadowRotation[i],e.alpha=this._shadowAlpha[i]}}_markReleased(t){void 0!==(null==t?void 0:t._interpIdx)&&(this._releasedIdx.push(t._interpIdx),t._interpIdx=void 0)}};
//# sourceMappingURL=index.cjs.map
